/* 참조에 의한 함수 호출방식
* 기본타입과 참조타입의 경우는 함수 호출 방식도 다르다.
* 기본타입의 경우는 값에 의한 호출 call by value 방식으로 동작한다.
* 즉 함수를 호출할때 인자로 기본 타입의 값을 넘길 경우, 호출된 함수의 매개변수로 복사된 값이 전달된다.
* 때문에 함수 내부에서 매개변수를 이용해 값을 변경해도, 실제로 호출된 변수의 값이 변경되지는 않는다.
* 이에반해 객체와 같은 참조타입의 경우 함수를 호출할 때 참조에 의한 호출 call by reference 방식으로 동작한다.
* 즉, 함수를 호출할 때 인자로 참조 타입인 객체를 전달할 경우, 객체의 프로퍼티값이 함수의 매개변수로 복사되지 않고,
* 인자로 넘긴 객체의 참조값이 그대로 함수 내부로 전달된다.
* 때문에 함수 내부에서 참조값을 이용해서 인자로 넘긴 실제 객체의 값을 변경할 수 있는것이다. */

//Call by Value와 Call by Reference 차이

var a = 100;
var objA = {value: 100};

function changeArg(num, obj) {

    num = 200;
    obj.value = 200;

    console.log(num);
    console.log(obj);

}

changeArg(a, objA);

console.log(a);
console.log(objA);

/* changeArg() 함수를 호출하면서, 인자값으로 기본타입인 숫자를 가진 변수 a와 참조타입인 객체 objA를 넘겼다.
* 함수 내부에서 매개변수 num과 obj를 이용해 인자로 전돨된 a와 objA.value의 값을 100에서 200으로 바꿨지만
* 함수 호출이 끝난 후에는 참조타입인 객체의 objA.value 프로퍼티만이 실제 값으로 변해있다는 것을 확인할 수 있다.
* 함수 내부에서 매개변수 num을 이용해서 100을 200으로 바꿔도 변수 a의 값은 변하지 않는다는것을 알수있다.
* 반면에 객체의 경우는 매개변수 obj로 objA가 참조하는 객체의 위치값이 그대로 전달되므로
* 실제 객체의 value 프로퍼티값이 changeArg() 함수 호출 후에도 적용되는것이다.  */